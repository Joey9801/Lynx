This software is designed to work on the Lynx dev r1 board, and other pin-compatible boards.
It takes in SPI data from SPI1, and generates streams of IQ values.
Error coding and constellation mapping is easily changeable.

Process:
The main loop in lynx.c manages the priorities of the various tasks
What needs to be done is stored in 'status', tasks of higher priorities are in the less significant bits of this value.
Every iteration of the main loop:
	If there is nothing being transmitted, and a packet is ready, transmission begins
	If there is a free input buffer, data input is enabled
	If there is a raw packet ready to be error coded, it is done (all in one go)
	UNLESS there is an error coded packet ready to be mapped to a constellation



Buffers and pointers:
there are 3 defines which determine the nature of the buffers
PACKETLENGTH is the number of bytes in each packet
BUFFERS is the number of sets of buffers

There are 4 buffers which store data in its various stages through signal processing.
Until the packet has finished transmitting, the buffers relevant to that packet are all unique to that set.

packet_raw[BUFFERS][PACKETLENGTH] is the raw data
packet_ecc[BUFFERS][PACKETLENGTH*2] is the error coded data
packet_constellation[BUFFERS][PACKETLENGTH*8][2] is a set of IQ points on the constellation
next_transmit[2] is next sample to be transmitted. When no pulse shaping is used, this is the same as the current row of packet_constellation.


There are number of pointers to the buffers which mark how much each algorithm has done.

input_buffer points to the next/current packet_raw which is to be written to
ecc_buffer points to the next packet_raw to be processed into a packet_ecc
constellation_buffer points to the next packet_ecc to be processed into a packet_constellation
transmit_buffer points to the next/current buffer to be transmitted

There are also a few pointers+buffers to do with the fir filter. These are described later


The status variables:
There are 6 bool values to describe the current status. They are as follows:

transmit_ready 		- There is a packet ready to be transmitted
constellation_ready 	- There is a packet ready to be mapped to a constellation
ecc_ready 		- There is a packet ready to be error coded
read_ready		- There is a free buffer for new data
currently_transmitting 	- There is a transmit currently happening
currently_reading 	- The current read buffer is still being filled

These bits are altered by the various algorithms on their completion.
Some of the algorithms run on interrupts, therefore the status bits are checked continuously in the main loop.
Each iteration of the main loop, the transmit ready, and read ready bits are checked, since they run on interrupts they dont hog the main loop.
ecc is only run if there isn't a pending constellation map

Reading data in:
Turn on the SPI DR not empty interrupt
Set 'currently_reading'
Set the ready pin high; this lets the data source know we are accepting new data
The interrupt will now place the next PACKET_LENGTH recieved bytes into packet_raw[input_buffer][]
After the last byte is put into packet_raw, input_buffer is increased by 1.
Set ecc_ready, to start error coding.
If transmit_buffer != input_buffer, then input_buffer must be pointing at an available buffer, read_ready remains true.

Error coding data:
Call an error coding function. There are references inside the function to ecc_buffer.
After the last byte is put into packet_ecc, ecc_buffer is increased by 1.
If transmit_buffer != ecc_buffer, then ecc_buffer must be pointing at an available buffer status bit 2 remains high.
Set constellation_ready to start constellation mapping.

Constellation mapping data:
Call an constellation mapping function. There are references inside the function to constellation_buffer.
After the last byte is put into packet_constellation, constellation_buffer is increased by 1.
If transmit_buffer != constellation_buffer, then constellation_buffer must be pointing at an available buffer status bit 2 remains high.
Set transmit_ready to start transmit.

